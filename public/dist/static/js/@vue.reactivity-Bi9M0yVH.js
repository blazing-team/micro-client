import{g as et}from"./@ctrl.tinycolor-DIJrhXRL.js";import{v as L,e as ie,h as W,w as Oe,x as Y,y as ne,g as A,z as fe,b as q,A as tt,E as st,B as N,u as it,C as nt,d as rt,D as at,F as ot,f as ct}from"./@vue.shared-Dggo55H6.js";function R(e,...t){}let v;class Pe{constructor(t=!1){this.detached=t,this._active=!0,this._on=0,this.effects=[],this.cleanups=[],this._isPaused=!1,this.parent=v,!t&&v&&(this.index=(v.scopes||(v.scopes=[])).push(this)-1)}get active(){return this._active}pause(){if(this._active){this._isPaused=!0;let t,s;if(this.scopes)for(t=0,s=this.scopes.length;t<s;t++)this.scopes[t].pause();for(t=0,s=this.effects.length;t<s;t++)this.effects[t].pause()}}resume(){if(this._active&&this._isPaused){this._isPaused=!1;let t,s;if(this.scopes)for(t=0,s=this.scopes.length;t<s;t++)this.scopes[t].resume();for(t=0,s=this.effects.length;t<s;t++)this.effects[t].resume()}}run(t){if(this._active){const s=v;try{return v=this,t()}finally{v=s}}else R("cannot run an inactive effect scope.")}on(){++this._on===1&&(this.prevScope=v,v=this)}off(){this._on>0&&--this._on===0&&(v=this.prevScope,this.prevScope=void 0)}stop(t){if(this._active){this._active=!1;let s,n;for(s=0,n=this.effects.length;s<n;s++)this.effects[s].stop();for(this.effects.length=0,s=0,n=this.cleanups.length;s<n;s++)this.cleanups[s]();if(this.cleanups.length=0,this.scopes){for(s=0,n=this.scopes.length;s<n;s++)this.scopes[s].stop(!0);this.scopes.length=0}if(!this.detached&&this.parent&&!t){const i=this.parent.scopes.pop();i&&i!==this&&(this.parent.scopes[this.index]=i,i.index=this.index)}this.parent=void 0}}}function ft(e){return new Pe(e)}function He(){return v}function lt(e,t=!1){v?v.cleanups.push(e):t||R("onScopeDispose() is called when there is no active effect scope to be associated with.")}let u;const ut={ACTIVE:1,1:"ACTIVE",RUNNING:2,2:"RUNNING",TRACKING:4,4:"TRACKING",NOTIFIED:8,8:"NOTIFIED",DIRTY:16,16:"DIRTY",ALLOW_RECURSE:32,32:"ALLOW_RECURSE",PAUSED:64,64:"PAUSED",EVALUATED:128,128:"EVALUATED"},we=new WeakSet;class z{constructor(t){this.fn=t,this.deps=void 0,this.depsTail=void 0,this.flags=5,this.next=void 0,this.cleanup=void 0,this.scheduler=void 0,v&&v.active&&v.effects.push(this)}pause(){this.flags|=64}resume(){this.flags&64&&(this.flags&=-65,we.has(this)&&(we.delete(this),this.trigger()))}notify(){this.flags&2&&!(this.flags&32)||this.flags&8||Ke(this)}run(){if(!(this.flags&1))return this.fn();this.flags|=2,Ce(this),Ne(this);const t=u,s=b;u=this,b=!0;try{return this.fn()}finally{u!==this&&R("Active effect was not restored correctly - this is likely a Vue internal bug."),je(this),u=t,b=s,this.flags&=-3}}stop(){if(this.flags&1){for(let t=this.deps;t;t=t.nextDep)Ee(t);this.deps=this.depsTail=void 0,Ce(this),this.onStop&&this.onStop(),this.flags&=-2}}trigger(){this.flags&64?we.add(this):this.scheduler?this.scheduler():this.runIfDirty()}runIfDirty(){Se(this)&&this.run()}get dirty(){return Se(this)}}let We=0,F,B;function Ke(e,t=!1){if(e.flags|=8,t){e.next=B,B=e;return}e.next=F,F=e}function Te(){We++}function me(){if(--We>0)return;if(B){let t=B;for(B=void 0;t;){const s=t.next;t.next=void 0,t.flags&=-9,t=s}}let e;for(;F;){let t=F;for(F=void 0;t;){const s=t.next;if(t.next=void 0,t.flags&=-9,t.flags&1)try{t.trigger()}catch(n){e||(e=n)}t=s}}if(e)throw e}function Ne(e){for(let t=e.deps;t;t=t.nextDep)t.version=-1,t.prevActiveLink=t.dep.activeLink,t.dep.activeLink=t}function je(e){let t,s=e.depsTail,n=s;for(;n;){const i=n.prevDep;n.version===-1?(n===s&&(s=i),Ee(n),ht(n)):t=n,n.dep.activeLink=n.prevActiveLink,n.prevActiveLink=void 0,n=i}e.deps=t,e.depsTail=s}function Se(e){for(let t=e.deps;t;t=t.nextDep)if(t.dep.version!==t.version||t.dep.computed&&(Ve(t.dep.computed)||t.dep.version!==t.version))return!0;return!!e._dirty}function Ve(e){if(e.flags&4&&!(e.flags&16)||(e.flags&=-17,e.globalVersion===J)||(e.globalVersion=J,!e.isSSR&&e.flags&128&&(!e.deps&&!e._dirty||!Se(e))))return;e.flags|=2;const t=e.dep,s=u,n=b;u=e,b=!0;try{Ne(e);const i=e.fn(e._value);(t.version===0||L(i,e._value))&&(e.flags|=128,e._value=i,t.version++)}catch(i){throw t.version++,i}finally{u=s,b=n,je(e),e.flags&=-3}}function Ee(e,t=!1){const{dep:s,prevSub:n,nextSub:i}=e;if(n&&(n.nextSub=i,e.prevSub=void 0),i&&(i.prevSub=n,e.nextSub=void 0),s.subsHead===e&&(s.subsHead=i),s.subs===e&&(s.subs=n,!n&&s.computed)){s.computed.flags&=-5;for(let r=s.computed.deps;r;r=r.nextDep)Ee(r,!0)}!t&&!--s.sc&&s.map&&s.map.delete(s.key)}function ht(e){const{prevDep:t,nextDep:s}=e;t&&(t.nextDep=s,e.prevDep=void 0),s&&(s.prevDep=t,e.nextDep=void 0)}function pt(e,t){e.effect instanceof z&&(e=e.effect.fn);const s=new z(e);t&&ie(s,t);try{s.run()}catch(i){throw s.stop(),i}const n=s.run.bind(s);return n.effect=s,n}function dt(e){e.effect.stop()}let b=!0;const xe=[];function Ae(){xe.push(b),b=!1}function _t(){xe.push(b),b=!0}function Ie(){const e=xe.pop();b=e===void 0?!0:e}function vt(e,t=!1){u instanceof z?u.cleanup=e:t||R("onEffectCleanup() was called when there was no active effect to associate with.")}function Ce(e){const{cleanup:t}=e;if(e.cleanup=void 0,t){const s=u;u=void 0;try{t()}finally{u=s}}}let J=0;class gt{constructor(t,s){this.sub=t,this.dep=s,this.version=s.version,this.nextDep=this.prevDep=this.nextSub=this.prevSub=this.prevActiveLink=void 0}}class le{constructor(t){this.computed=t,this.version=0,this.activeLink=void 0,this.subs=void 0,this.map=void 0,this.key=void 0,this.sc=0,this.__v_skip=!0,this.subsHead=void 0}track(t){if(!u||!b||u===this.computed)return;let s=this.activeLink;if(s===void 0||s.sub!==u)s=this.activeLink=new gt(u,this),u.deps?(s.prevDep=u.depsTail,u.depsTail.nextDep=s,u.depsTail=s):u.deps=u.depsTail=s,$e(s);else if(s.version===-1&&(s.version=this.version,s.nextDep)){const n=s.nextDep;n.prevDep=s.prevDep,s.prevDep&&(s.prevDep.nextDep=n),s.prevDep=u.depsTail,s.nextDep=void 0,u.depsTail.nextDep=s,u.depsTail=s,u.deps===s&&(u.deps=n)}return u.onTrack&&u.onTrack(ie({effect:u},t)),s}trigger(t){this.version++,J++,this.notify(t)}notify(t){Te();try{for(let s=this.subsHead;s;s=s.nextSub)s.sub.onTrigger&&!(s.sub.flags&8)&&s.sub.onTrigger(ie({effect:s.sub},t));for(let s=this.subs;s;s=s.prevSub)s.sub.notify()&&s.sub.dep.notify()}finally{me()}}}function $e(e){if(e.dep.sc++,e.sub.flags&4){const t=e.dep.computed;if(t&&!e.dep.subs){t.flags|=20;for(let n=t.deps;n;n=n.nextDep)$e(n)}const s=e.dep.subs;s!==e&&(e.prevSub=s,s&&(s.nextSub=e)),e.dep.subsHead===void 0&&(e.dep.subsHead=e),e.dep.subs=e}}const re=new WeakMap,M=Symbol("Object iterate"),ae=Symbol("Map keys iterate"),j=Symbol("Array iterate");function w(e,t,s){if(b&&u){let n=re.get(e);n||re.set(e,n=new Map);let i=n.get(s);i||(n.set(s,i=new le),i.map=n,i.key=s),i.track({target:e,type:t,key:s})}}function E(e,t,s,n,i,r){const a=re.get(e);if(!a){J++;return}const o=c=>{c&&c.trigger({target:e,type:t,key:s,newValue:n,oldValue:i,oldTarget:r})};if(Te(),t==="clear")a.forEach(o);else{const c=A(e),p=c&&fe(s);if(c&&s==="length"){const _=Number(n);a.forEach((f,d)=>{(d==="length"||d===j||!q(d)&&d>=_)&&o(f)})}else switch((s!==void 0||a.has(void 0))&&o(a.get(s)),p&&o(a.get(j)),t){case"add":c?p&&o(a.get("length")):(o(a.get(M)),N(e)&&o(a.get(ae)));break;case"delete":c||(o(a.get(M)),N(e)&&o(a.get(ae)));break;case"set":N(e)&&o(a.get(M));break}}me()}function wt(e,t){const s=re.get(e);return s&&s.get(t)}function P(e){const t=h(e);return t===e?t:(w(t,"iterate",j),S(e)?t:t.map(T))}function ue(e){return w(e=h(e),"iterate",j),e}function D(e,t){return I(e)?H(e)?V(T(t)):V(t):T(t)}const Rt={__proto__:null,[Symbol.iterator](){return Re(this,Symbol.iterator,e=>D(this,e))},concat(...e){return P(this).concat(...e.map(t=>A(t)?P(t):t))},entries(){return Re(this,"entries",e=>(e[1]=D(this,e[1]),e))},every(e,t){return m(this,"every",e,t,void 0,arguments)},filter(e,t){return m(this,"filter",e,t,s=>s.map(n=>D(this,n)),arguments)},find(e,t){return m(this,"find",e,t,s=>D(this,s),arguments)},findIndex(e,t){return m(this,"findIndex",e,t,void 0,arguments)},findLast(e,t){return m(this,"findLast",e,t,s=>D(this,s),arguments)},findLastIndex(e,t){return m(this,"findLastIndex",e,t,void 0,arguments)},forEach(e,t){return m(this,"forEach",e,t,void 0,arguments)},includes(...e){return be(this,"includes",e)},indexOf(...e){return be(this,"indexOf",e)},join(e){return P(this).join(e)},lastIndexOf(...e){return be(this,"lastIndexOf",e)},map(e,t){return m(this,"map",e,t,void 0,arguments)},pop(){return U(this,"pop")},push(...e){return U(this,"push",e)},reduce(e,...t){return Le(this,"reduce",e,t)},reduceRight(e,...t){return Le(this,"reduceRight",e,t)},shift(){return U(this,"shift")},some(e,t){return m(this,"some",e,t,void 0,arguments)},splice(...e){return U(this,"splice",e)},toReversed(){return P(this).toReversed()},toSorted(e){return P(this).toSorted(e)},toSpliced(...e){return P(this).toSpliced(...e)},unshift(...e){return U(this,"unshift",e)},values(){return Re(this,"values",e=>D(this,e))}};function Re(e,t,s){const n=ue(e),i=n[t]();return n!==e&&!S(e)&&(i._next=i.next,i.next=()=>{const r=i._next();return r.done||(r.value=s(r.value)),r}),i}const bt=Array.prototype;function m(e,t,s,n,i,r){const a=ue(e),o=a!==e&&!S(e),c=a[t];if(c!==bt[t]){const f=c.apply(e,r);return o?T(f):f}let p=s;a!==e&&(o?p=function(f,d){return s.call(this,D(e,f),d,e)}:s.length>2&&(p=function(f,d){return s.call(this,f,d,e)}));const _=c.call(a,p,n);return o&&i?i(_):_}function Le(e,t,s,n){const i=ue(e);let r=s;return i!==e&&(S(e)?s.length>3&&(r=function(a,o,c){return s.call(this,a,o,c,e)}):r=function(a,o,c){return s.call(this,a,D(e,o),c,e)}),i[t](r,...n)}function be(e,t,s){const n=h(e);w(n,"iterate",j);const i=n[t](...s);return(i===-1||i===!1)&&de(s[0])?(s[0]=h(s[0]),n[t](...s)):i}function U(e,t,s=[]){Ae(),Te();const n=h(e)[t].apply(e,s);return me(),Ie(),n}const St=it("__proto__,__v_isRef,__isVue"),Ge=new Set(Object.getOwnPropertyNames(Symbol).filter(e=>e!=="arguments"&&e!=="caller").map(e=>Symbol[e]).filter(q));function yt(e){q(e)||(e=String(e));const t=h(this);return w(t,"has",e),t.hasOwnProperty(e)}class Ue{constructor(t=!1,s=!1){this._isReadonly=t,this._isShallow=s}get(t,s,n){if(s==="__v_skip")return t.__v_skip;const i=this._isReadonly,r=this._isShallow;if(s==="__v_isReactive")return!i;if(s==="__v_isReadonly")return i;if(s==="__v_isShallow")return r;if(s==="__v_raw")return n===(i?r?qe:Je:r?ze:Ye).get(t)||Object.getPrototypeOf(t)===Object.getPrototypeOf(n)?t:void 0;const a=A(t);if(!i){let c;if(a&&(c=Rt[s]))return c;if(s==="hasOwnProperty")return yt}const o=Reflect.get(t,s,g(t)?t:n);if((q(s)?Ge.has(s):St(s))||(i||w(t,"get",s),r))return o;if(g(o)){const c=a&&fe(s)?o:o.value;return i&&W(c)?oe(c):c}return W(o)?i?oe(o):De(o):o}}class Fe extends Ue{constructor(t=!1){super(!1,t)}set(t,s,n,i){let r=t[s];const a=A(t)&&fe(s);if(!this._isShallow){const p=I(r);if(!S(n)&&!I(n)&&(r=h(r),n=h(n)),!a&&g(r)&&!g(n))return p?(R(`Set operation on key "${String(s)}" failed: target is readonly.`,t[s]),!0):(r.value=n,!0)}const o=a?Number(s)<t.length:ne(t,s),c=Reflect.set(t,s,n,g(t)?t:i);return t===h(i)&&(o?L(n,r)&&E(t,"set",s,n,r):E(t,"add",s,n)),c}deleteProperty(t,s){const n=ne(t,s),i=t[s],r=Reflect.deleteProperty(t,s);return r&&n&&E(t,"delete",s,void 0,i),r}has(t,s){const n=Reflect.has(t,s);return(!q(s)||!Ge.has(s))&&w(t,"has",s),n}ownKeys(t){return w(t,"iterate",A(t)?"length":M),Reflect.ownKeys(t)}}class Be extends Ue{constructor(t=!1){super(!0,t)}set(t,s){return R(`Set operation on key "${String(s)}" failed: target is readonly.`,t),!0}deleteProperty(t,s){return R(`Delete operation on key "${String(s)}" failed: target is readonly.`,t),!0}}const Tt=new Fe,mt=new Be,Et=new Fe(!0),xt=new Be(!0),ye=e=>e,ee=e=>Reflect.getPrototypeOf(e);function At(e,t,s){return function(...n){const i=this.__v_raw,r=h(i),a=N(r),o=e==="entries"||e===Symbol.iterator&&a,c=e==="keys"&&a,p=i[e](...n),_=s?ye:t?V:T;return!t&&w(r,"iterate",c?ae:M),{next(){const{value:f,done:d}=p.next();return d?{value:f,done:d}:{value:o?[_(f[0]),_(f[1])]:_(f),done:d}},[Symbol.iterator](){return this}}}}function te(e){return function(...t){{const s=t[0]?`on key "${t[0]}" `:"";R(`${rt(e)} operation ${s}failed: target is readonly.`,h(this))}return e==="delete"?!1:e==="clear"?void 0:this}}function It(e,t){const s={get(i){const r=this.__v_raw,a=h(r),o=h(i);e||(L(i,o)&&w(a,"get",i),w(a,"get",o));const{has:c}=ee(a),p=t?ye:e?V:T;if(c.call(a,i))return p(r.get(i));if(c.call(a,o))return p(r.get(o));r!==a&&r.get(i)},get size(){const i=this.__v_raw;return!e&&w(h(i),"iterate",M),i.size},has(i){const r=this.__v_raw,a=h(r),o=h(i);return e||(L(i,o)&&w(a,"has",i),w(a,"has",o)),i===o?r.has(i):r.has(i)||r.has(o)},forEach(i,r){const a=this,o=a.__v_raw,c=h(o),p=t?ye:e?V:T;return!e&&w(c,"iterate",M),o.forEach((_,f)=>i.call(r,p(_),p(f),a))}};return ie(s,e?{add:te("add"),set:te("set"),delete:te("delete"),clear:te("clear")}:{add(i){!t&&!S(i)&&!I(i)&&(i=h(i));const r=h(this);return ee(r).has.call(r,i)||(r.add(i),E(r,"add",i,i)),this},set(i,r){!t&&!S(r)&&!I(r)&&(r=h(r));const a=h(this),{has:o,get:c}=ee(a);let p=o.call(a,i);p?Me(a,o,i):(i=h(i),p=o.call(a,i));const _=c.call(a,i);return a.set(i,r),p?L(r,_)&&E(a,"set",i,r,_):E(a,"add",i,r),this},delete(i){const r=h(this),{has:a,get:o}=ee(r);let c=a.call(r,i);c?Me(r,a,i):(i=h(i),c=a.call(r,i));const p=o?o.call(r,i):void 0,_=r.delete(i);return c&&E(r,"delete",i,void 0,p),_},clear(){const i=h(this),r=i.size!==0,a=N(i)?new Map(i):new Set(i),o=i.clear();return r&&E(i,"clear",void 0,void 0,a),o}}),["keys","values","entries",Symbol.iterator].forEach(i=>{s[i]=At(i,e,t)}),s}function he(e,t){const s=It(e,t);return(n,i,r)=>i==="__v_isReactive"?!e:i==="__v_isReadonly"?e:i==="__v_raw"?n:Reflect.get(ne(s,i)&&i in n?s:n,i,r)}const Dt={get:he(!1,!1)},Ct={get:he(!1,!0)},Lt={get:he(!0,!1)},Mt={get:he(!0,!0)};function Me(e,t,s){const n=h(s);if(n!==s&&t.call(e,n)){const i=Oe(e);R(`Reactive ${i} contains both the raw and reactive versions of the same object${i==="Map"?" as keys":""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`)}}const Ye=new WeakMap,ze=new WeakMap,Je=new WeakMap,qe=new WeakMap;function Ot(e){switch(e){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function Pt(e){return e.__v_skip||!Object.isExtensible(e)?0:Ot(Oe(e))}function De(e){return I(e)?e:pe(e,!1,Tt,Dt,Ye)}function Ht(e){return pe(e,!1,Et,Ct,ze)}function oe(e){return pe(e,!0,mt,Lt,Je)}function Wt(e){return pe(e,!0,xt,Mt,qe)}function pe(e,t,s,n,i){if(!W(e))return R(`value cannot be made ${t?"readonly":"reactive"}: ${String(e)}`),e;if(e.__v_raw&&!(t&&e.__v_isReactive))return e;const r=Pt(e);if(r===0)return e;const a=i.get(e);if(a)return a;const o=new Proxy(e,r===2?n:s);return i.set(e,o),o}function H(e){return I(e)?H(e.__v_raw):!!(e&&e.__v_isReactive)}function I(e){return!!(e&&e.__v_isReadonly)}function S(e){return!!(e&&e.__v_isShallow)}function de(e){return e?!!e.__v_raw:!1}function h(e){const t=e&&e.__v_raw;return t?h(t):e}function Kt(e){return!ne(e,"__v_skip")&&Object.isExtensible(e)&&tt(e,"__v_skip",!0),e}const T=e=>W(e)?De(e):e,V=e=>W(e)?oe(e):e;function g(e){return e?e.__v_isRef===!0:!1}function Qe(e){return Xe(e,!1)}function Nt(e){return Xe(e,!0)}function Xe(e,t){return g(e)?e:new jt(e,t)}class jt{constructor(t,s){this.dep=new le,this.__v_isRef=!0,this.__v_isShallow=!1,this._rawValue=s?t:h(t),this._value=s?t:T(t),this.__v_isShallow=s}get value(){return this.dep.track({target:this,type:"get",key:"value"}),this._value}set value(t){const s=this._rawValue,n=this.__v_isShallow||S(t)||I(t);t=n?t:h(t),L(t,s)&&(this._rawValue=t,this._value=n?t:T(t),this.dep.trigger({target:this,type:"set",key:"value",newValue:t,oldValue:s}))}}function Vt(e){e.dep&&e.dep.trigger({target:e,type:"set",key:"value",newValue:e._value})}function _e(e){return g(e)?e.value:e}function $t(e){return Y(e)?e():_e(e)}const Gt={get:(e,t,s)=>t==="__v_raw"?e:_e(Reflect.get(e,t,s)),set:(e,t,s,n)=>{const i=e[t];return g(i)&&!g(s)?(i.value=s,!0):Reflect.set(e,t,s,n)}};function Ut(e){return H(e)?e:new Proxy(e,Gt)}class Ft{constructor(t){this.__v_isRef=!0,this._value=void 0;const s=this.dep=new le,{get:n,set:i}=t(s.track.bind(s),s.trigger.bind(s));this._get=n,this._set=i}get value(){return this._value=this._get()}set value(t){this._set(t)}}function Bt(e){return new Ft(e)}function Yt(e){de(e)||R("toRefs() expects a reactive object but received a plain one.");const t=A(e)?new Array(e.length):{};for(const s in e)t[s]=Ze(e,s);return t}class zt{constructor(t,s,n){this._object=t,this._key=s,this._defaultValue=n,this.__v_isRef=!0,this._value=void 0,this._raw=h(t);let i=!0,r=t;if(!A(t)||!fe(String(s)))do i=!de(r)||S(r);while(i&&(r=r.__v_raw));this._shallow=i}get value(){let t=this._object[this._key];return this._shallow&&(t=_e(t)),this._value=t===void 0?this._defaultValue:t}set value(t){if(this._shallow&&g(this._raw[this._key])){const s=this._object[this._key];if(g(s)){s.value=t;return}}this._object[this._key]=t}get dep(){return wt(this._raw,this._key)}}class Jt{constructor(t){this._getter=t,this.__v_isRef=!0,this.__v_isReadonly=!0,this._value=void 0}get value(){return this._value=this._getter()}}function qt(e,t,s){return g(e)?e:Y(e)?new Jt(e):W(e)&&arguments.length>1?Ze(e,t,s):Qe(e)}function Ze(e,t,s){return new zt(e,t,s)}class Qt{constructor(t,s,n){this.fn=t,this.setter=s,this._value=void 0,this.dep=new le(this),this.__v_isRef=!0,this.deps=void 0,this.depsTail=void 0,this.flags=16,this.globalVersion=J-1,this.next=void 0,this.effect=this,this.__v_isReadonly=!s,this.isSSR=n}notify(){if(this.flags|=16,!(this.flags&8)&&u!==this)return Ke(this,!0),!0}get value(){const t=this.dep.track({target:this,type:"get",key:"value"});return Ve(this),t&&(t.version=this.dep.version),this._value}set value(t){this.setter?this.setter(t):R("Write operation failed: computed value is readonly")}}function Xt(e,t,s=!1){let n,i;Y(e)?n=e:(n=e.get,i=e.set);const r=new Qt(n,i,s);return t&&!s&&(r.onTrack=t.onTrack,r.onTrigger=t.onTrigger),r}const Zt={GET:"get",HAS:"has",ITERATE:"iterate"},kt={SET:"set",ADD:"add",DELETE:"delete",CLEAR:"clear"},es={SKIP:"__v_skip",IS_REACTIVE:"__v_isReactive",IS_READONLY:"__v_isReadonly",IS_SHALLOW:"__v_isShallow",RAW:"__v_raw",IS_REF:"__v_isRef"},ts={WATCH_GETTER:2,2:"WATCH_GETTER",WATCH_CALLBACK:3,3:"WATCH_CALLBACK",WATCH_CLEANUP:4,4:"WATCH_CLEANUP"},se={},ce=new WeakMap;let C;function ss(){return C}function ke(e,t=!1,s=C){if(s){let n=ce.get(s);n||ce.set(s,n=[]),n.push(e)}else t||R("onWatcherCleanup() was called when there was no active watcher to associate with.")}function is(e,t,s=st){const{immediate:n,deep:i,once:r,scheduler:a,augmentJob:o,call:c}=s,p=l=>{(s.onWarn||R)("Invalid watch source: ",l,"A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.")},_=l=>i?l:S(l)||i===!1||i===0?x(l,1):x(l);let f,d,$,Q,X=!1,Z=!1;if(g(e)?(d=()=>e.value,X=S(e)):H(e)?(d=()=>_(e),X=!0):A(e)?(Z=!0,X=e.some(l=>H(l)||S(l)),d=()=>e.map(l=>{if(g(l))return l.value;if(H(l))return _(l);if(Y(l))return c?c(l,2):l();p(l)})):Y(e)?t?d=c?()=>c(e,2):e:d=()=>{if($){Ae();try{$()}finally{Ie()}}const l=C;C=f;try{return c?c(e,3,[Q]):e(Q)}finally{C=l}}:(d=ct,p(e)),t&&i){const l=d,y=i===!0?1/0:i;d=()=>x(l(),y)}const ve=He(),K=()=>{f.stop(),ve&&ve.active&&nt(ve.effects,f)};if(r&&t){const l=t;t=(...y)=>{l(...y),K()}}let O=Z?new Array(e.length).fill(se):se;const G=l=>{if(!(!(f.flags&1)||!f.dirty&&!l))if(t){const y=f.run();if(i||X||(Z?y.some((ge,k)=>L(ge,O[k])):L(y,O))){$&&$();const ge=C;C=f;try{const k=[y,O===se?void 0:Z&&O[0]===se?[]:O,Q];O=y,c?c(t,3,k):t(...k)}finally{C=ge}}}else f.run()};return o&&o(G),f=new z(d),f.scheduler=a?()=>a(G,!1):G,Q=l=>ke(l,!1,f),$=f.onStop=()=>{const l=ce.get(f);if(l){if(c)c(l,4);else for(const y of l)y();ce.delete(f)}},f.onTrack=s.onTrack,f.onTrigger=s.onTrigger,t?n?G(!0):O=f.run():a?a(G.bind(null,!0),!0):f.run(),K.pause=f.pause.bind(f),K.resume=f.resume.bind(f),K.stop=K,K}function x(e,t=1/0,s){if(t<=0||!W(e)||e.__v_skip||(s=s||new Map,(s.get(e)||0)>=t))return e;if(s.set(e,t),t--,g(e))x(e.value,t,s);else if(A(e))for(let n=0;n<e.length;n++)x(e[n],t,s);else if(at(e)||N(e))e.forEach(n=>{x(n,t,s)});else if(ot(e)){for(const n in e)x(e[n],t,s);for(const n of Object.getOwnPropertySymbols(e))Object.prototype.propertyIsEnumerable.call(e,n)&&x(e[n],t,s)}return e}const ns=Object.freeze(Object.defineProperty({__proto__:null,ARRAY_ITERATE_KEY:j,EffectFlags:ut,EffectScope:Pe,ITERATE_KEY:M,MAP_KEY_ITERATE_KEY:ae,ReactiveEffect:z,ReactiveFlags:es,TrackOpTypes:Zt,TriggerOpTypes:kt,WatchErrorCodes:ts,computed:Xt,customRef:Bt,effect:pt,effectScope:ft,enableTracking:_t,getCurrentScope:He,getCurrentWatcher:ss,isProxy:de,isReactive:H,isReadonly:I,isRef:g,isShallow:S,markRaw:Kt,onEffectCleanup:vt,onScopeDispose:lt,onWatcherCleanup:ke,pauseTracking:Ae,proxyRefs:Ut,reactive:De,reactiveReadArray:P,readonly:oe,ref:Qe,resetTracking:Ie,shallowReactive:Ht,shallowReadArray:ue,shallowReadonly:Wt,shallowRef:Nt,stop:dt,toRaw:h,toReactive:T,toReadonly:V,toRef:qt,toRefs:Yt,toValue:$t,track:w,traverse:x,trigger:E,triggerRef:Vt,unref:_e,watch:is},Symbol.toStringTag,{value:"Module"})),os=et(ns);export{kt as A,pt as B,ft as C,He as D,Pe as E,ss as F,lt as G,ke as H,dt as I,qt as J,Yt as K,$t as L,Vt as M,os as N,z as R,Zt as T,De as a,H as b,Bt as c,S as d,I as e,de as f,Xt as g,x as h,g as i,ue as j,V as k,T as l,Kt as m,Wt as n,w as o,Ut as p,Ae as q,Qe as r,Nt as s,h as t,_e as u,Ie as v,is as w,Ht as x,E as y,oe as z};
